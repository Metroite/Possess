<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">

    <title>Web Audio API Test</title>

    <link rel="stylesheet" href="">
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>

  <body>
    <h1>Microphone Gain and Reverb</h1>
    <p>Volume</p>
    <input id="volume" type="range" min="0" max="1" step="0.1" value="0.5"/>
    <p>Reverb</p>
    <input id="reverb" type="range" min="0" max="1" step="0.1" value="0.5"/>
    <pre></pre>
  </body>
<script>


const pre = document.querySelector('pre');
const myScript = document.querySelector('script');
pre.innerHTML = myScript.innerHTML;

const BUFF_SIZE = 16384;
let microphone_stream = null,
    gain_node = null,
    reverb_node = null;
    audioContext = null;

try {
  audioContext = new AudioContext();
  console.log("audio is starting up ...");
}
catch (err) {
   alert("err.message");
}


// Older browsers might not implement mediaDevices at all, so we set an empty object first
if (navigator.mediaDevices === undefined) {
  navigator.mediaDevices = {};
}

// Some browsers partially implement mediaDevices. We can't just assign an object
// with getUserMedia as it would overwrite existing properties.
// Here, we will just add the getUserMedia property if it's missing.
if (navigator.mediaDevices.getUserMedia === undefined) {
  navigator.mediaDevices.getUserMedia = function(constraints) {

    // First get ahold of the legacy getUserMedia, if present
    var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

    // Some browsers just don't implement it - return a rejected promise with an error
    // to keep a consistent interface
    if (!getUserMedia) {
      return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
    }

    // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
    return new Promise(function(resolve, reject) {
      getUserMedia.call(navigator, constraints, resolve, reject);
    });
  }
}


///RELEVANT:
navigator.mediaDevices.getUserMedia({ audio: true, video: false })

.then(function(stream) {
  start_microphone(stream);
})

.catch(function(err) {
  console.log(err.name + ": " + err.message);
});


let reverb = createReverb();
async function createReverb() {
    let convolver = audioContext.createConvolver();

    // load impulse response from file
    let response     = await fetch("impulse-response.wav");
    let arraybuffer  = await response.arrayBuffer();
    convolver.buffer = await audioContext.decodeAudioData(arraybuffer);

    return convolver;
}



function start_microphone(stream){
  gain_node = audioContext.createGain();
  microphone_stream = audioContext.createMediaStreamSource(stream);

  // microphone_stream -> reverb -> gain -> destination
  microphone_stream.connect(reverb);
  reverb.connect(gain_node);
  gain_node.connect(audioContext.destination);



  // --- enable volume and reverb control for output speakers
  document.getElementById('reverb').addEventListener('change', function() {

      var curr_reverb = this.value;
      reverb_node.convolve.value = curr_reverb;

      console.log("curr_reverb ", curr_reverb);
  });
  document.getElementById('volume').addEventListener('change', function() {

      var curr_volume = this.value;
      gain_node.gain.value = curr_volume;

      console.log("curr_volume ", curr_volume);
  });
}

</script>
</html>
